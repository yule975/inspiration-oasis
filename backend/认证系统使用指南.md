# JWT认证系统使用指南

## 🔐 系统概述

我们已经成功实现了完整的JWT认证系统，支持：

### ✅ 核心功能
- **用户注册** - 安全的用户账户创建
- **用户登录** - JWT令牌生成和验证
- **令牌刷新** - 自动延长会话有效期
- **密码管理** - 安全的密码修改和重置
- **用户信息管理** - 个人资料更新
- **角色权限控制** - 基于角色的访问控制
- **会话管理** - 完整的登录状态追踪

### 🛡️ 安全特性
- **密码加密** - bcrypt哈希加盐存储
- **JWT令牌** - 安全的访问令牌和刷新令牌
- **令牌过期** - 自动过期和刷新机制
- **用户状态验证** - 实时验证用户活跃状态
- **密码强度要求** - 大小写字母和数字组合
- **登录状态追踪** - 最后登录时间记录

## 🚀 快速开始

### 1. 环境变量配置

在 `.env` 文件中配置：

```bash
# JWT配置
JWT_SECRET=your-super-secret-jwt-key-here
JWT_REFRESH_SECRET=your-super-secret-refresh-key-here
JWT_EXPIRES_IN=24h
JWT_REFRESH_EXPIRES_IN=7d

# 密码加密配置
BCRYPT_SALT_ROUNDS=12

# 应用配置
BASE_URL=http://localhost:3001
CORS_ORIGIN=http://localhost:3000
```

### 2. 数据库迁移

```bash
# 生成数据库迁移
pnpm db:generate

# 应用迁移到数据库
pnpm db:push

# 重新生成种子数据
pnpm db:seed
```

## 📡 API接口使用

### 1. 用户注册

```bash
curl -X POST http://localhost:3001/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "SecurePass123",
    "name": "张三",
    "avatar": "https://example.com/avatar.jpg"
  }'
```

**响应示例：**
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "user_123",
      "email": "user@example.com",
      "name": "张三",
      "avatar": "https://example.com/avatar.jpg",
      "role": "user",
      "createdAt": "2023-11-16T10:00:00.000Z"
    },
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 86400
  },
  "message": "注册成功"
}
```

### 2. 用户登录

```bash
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "SecurePass123"
  }'
```

### 3. 使用访问令牌

```bash
# 获取用户信息
curl http://localhost:3001/api/auth/profile \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"

# 创建灵感（需要认证）
curl -X POST http://localhost:3001/api/ideas \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -d '{
    "content": "使用JWT认证的新灵感",
    "tags": ["JWT", "认证", "安全"]
  }'
```

### 4. 刷新令牌

```bash
curl -X POST http://localhost:3001/api/auth/refresh-token \
  -H "Content-Type: application/json" \
  -d '{
    "refreshToken": "YOUR_REFRESH_TOKEN"
  }'
```

### 5. 修改密码

```bash
curl -X POST http://localhost:3001/api/auth/change-password \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -d '{
    "oldPassword": "SecurePass123",
    "newPassword": "NewSecurePass456"
  }'
```

### 6. 密码重置

```bash
# 请求密码重置
curl -X POST http://localhost:3001/api/auth/request-password-reset \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com"
  }'

# 重置密码
curl -X POST http://localhost:3001/api/auth/reset-password \
  -H "Content-Type: application/json" \
  -d '{
    "token": "RESET_TOKEN_FROM_EMAIL",
    "password": "NewSecurePass456"
  }'
```

### 7. 用户登出

```bash
curl -X POST http://localhost:3001/api/auth/logout \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

## 🔧 认证中间件使用

### 1. 强制认证

```typescript
import { authenticateUser } from '@/middleware/auth'

// 需要登录的路由
router.get('/protected', authenticateUser, (req, res) => {
  const user = req.user // 已认证的用户信息
  res.json({ user })
})
```

### 2. 可选认证

```typescript
import { optionalAuth } from '@/middleware/auth'

// 可选登录的路由（支持游客访问）
router.get('/public', optionalAuth, (req, res) => {
  const user = req.user // 可能为空
  res.json({ 
    isAuthenticated: !!user,
    user: user || null 
  })
})
```

### 3. 角色权限控制

```typescript
import { authenticateUser, requireAdmin } from '@/middleware/auth'

// 只有管理员可以访问
router.post('/admin-only', 
  authenticateUser, 
  requireAdmin, 
  (req, res) => {
    res.json({ message: '管理员功能' })
  }
)
```

### 4. 向后兼容（开发测试）

```typescript
import { authenticateUserSimple } from '@/middleware/auth'

// 使用简化认证（Header方式）
router.get('/dev-test', authenticateUserSimple, (req, res) => {
  res.json({ user: req.user })
})
```

## 🎯 前端集成示例

### 1. React Hook示例

```typescript
// useAuth.ts
import { useState, useEffect } from 'react'

interface User {
  id: string
  email: string
  name: string
  role: string
}

interface AuthState {
  user: User | null
  token: string | null
  isAuthenticated: boolean
  isLoading: boolean
}

export function useAuth() {
  const [authState, setAuthState] = useState<AuthState>({
    user: null,
    token: localStorage.getItem('access_token'),
    isAuthenticated: false,
    isLoading: true
  })

  // 登录
  const login = async (email: string, password: string) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      })

      const data = await response.json()
      
      if (data.success) {
        localStorage.setItem('access_token', data.data.token)
        localStorage.setItem('refresh_token', data.data.refreshToken)
        
        setAuthState({
          user: data.data.user,
          token: data.data.token,
          isAuthenticated: true,
          isLoading: false
        })
      }
      
      return data
    } catch (error) {
      console.error('登录失败:', error)
      throw error
    }
  }

  // 登出
  const logout = async () => {
    try {
      const token = localStorage.getItem('access_token')
      if (token) {
        await fetch('/api/auth/logout', {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        })
      }
    } catch (error) {
      console.error('登出请求失败:', error)
    } finally {
      localStorage.removeItem('access_token')
      localStorage.removeItem('refresh_token')
      setAuthState({
        user: null,
        token: null,
        isAuthenticated: false,
        isLoading: false
      })
    }
  }

  // 验证令牌
  const verifyToken = async () => {
    const token = localStorage.getItem('access_token')
    if (!token) {
      setAuthState(prev => ({ ...prev, isLoading: false }))
      return
    }

    try {
      const response = await fetch('/api/auth/verify-token', {
        headers: { 'Authorization': `Bearer ${token}` }
      })

      if (response.ok) {
        const data = await response.json()
        setAuthState({
          user: data.data.user,
          token,
          isAuthenticated: true,
          isLoading: false
        })
      } else {
        // 令牌无效，尝试刷新
        await refreshToken()
      }
    } catch (error) {
      console.error('令牌验证失败:', error)
      await logout()
    }
  }

  // 刷新令牌
  const refreshToken = async () => {
    const refreshToken = localStorage.getItem('refresh_token')
    if (!refreshToken) {
      await logout()
      return
    }

    try {
      const response = await fetch('/api/auth/refresh-token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken })
      })

      if (response.ok) {
        const data = await response.json()
        localStorage.setItem('access_token', data.data.token)
        localStorage.setItem('refresh_token', data.data.refreshToken)
        
        setAuthState({
          user: data.data.user,
          token: data.data.token,
          isAuthenticated: true,
          isLoading: false
        })
      } else {
        await logout()
      }
    } catch (error) {
      console.error('刷新令牌失败:', error)
      await logout()
    }
  }

  useEffect(() => {
    verifyToken()
  }, [])

  return {
    ...authState,
    login,
    logout,
    refreshToken
  }
}
```

### 2. API请求拦截器

```typescript
// apiClient.ts
class ApiClient {
  private baseURL = process.env.REACT_APP_API_URL || 'http://localhost:3001'

  async request(endpoint: string, options: RequestInit = {}) {
    const token = localStorage.getItem('access_token')
    
    const config: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...(token && { Authorization: `Bearer ${token}` }),
        ...options.headers
      }
    }

    let response = await fetch(`${this.baseURL}${endpoint}`, config)

    // 如果401错误，尝试刷新令牌
    if (response.status === 401 && token) {
      const refreshed = await this.refreshToken()
      if (refreshed) {
        // 重试原请求
        config.headers = {
          ...config.headers,
          Authorization: `Bearer ${localStorage.getItem('access_token')}`
        }
        response = await fetch(`${this.baseURL}${endpoint}`, config)
      }
    }

    return response
  }

  private async refreshToken(): Promise<boolean> {
    const refreshToken = localStorage.getItem('refresh_token')
    if (!refreshToken) return false

    try {
      const response = await fetch(`${this.baseURL}/api/auth/refresh-token`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken })
      })

      if (response.ok) {
        const data = await response.json()
        localStorage.setItem('access_token', data.data.token)
        localStorage.setItem('refresh_token', data.data.refreshToken)
        return true
      }
    } catch (error) {
      console.error('刷新令牌失败:', error)
    }

    return false
  }
}

export const apiClient = new ApiClient()
```

## 🔄 迁移指南

### 从简化认证升级到JWT

1. **现有用户数据迁移**：
   ```sql
   -- 为现有用户添加邮箱（如果没有）
   UPDATE users SET email = id || '@temp.com' WHERE email IS NULL;
   
   -- 设置默认角色
   UPDATE users SET role = 'user' WHERE role IS NULL;
   
   -- 激活所有现有用户
   UPDATE users SET isActive = true WHERE isActive IS NULL;
   ```

2. **前端代码更新**：
   - 替换Header认证为Bearer Token
   - 添加令牌刷新逻辑
   - 更新登录/注册流程

3. **向后兼容**：
   - 系统同时支持JWT和Header认证
   - 使用 `optionalAuth` 中间件平滑过渡
   - 逐步迁移各个接口

## 🔍 故障排查

### 常见问题

1. **令牌无效错误**
   ```bash
   # 检查令牌格式
   echo "YOUR_TOKEN" | base64 -d
   
   # 验证令牌
   curl http://localhost:3001/api/auth/verify-token \
     -H "Authorization: Bearer YOUR_TOKEN"
   ```

2. **密码强度不符合要求**
   - 密码必须至少8位
   - 必须包含大写字母、小写字母和数字
   - 示例：`SecurePass123`

3. **邮箱已存在**
   - 检查数据库中是否已有该邮箱
   - 使用不同邮箱注册或进行密码重置

4. **刷新令牌失效**
   - 检查Redis连接状态
   - 确认刷新令牌未过期
   - 重新登录获取新令牌

### 调试方法

```typescript
// 启用JWT调试日志
process.env.DEBUG = 'jwt'

// 检查令牌内容
const jwt = require('jsonwebtoken')
const decoded = jwt.decode(token, { complete: true })
console.log('令牌内容:', decoded)
```

## 🎉 测试完成标志

当以下功能正常工作时，说明认证系统运行正常：

✅ 用户可以成功注册和登录  
✅ JWT令牌正确生成和验证  
✅ 刷新令牌自动更新会话  
✅ 密码修改和重置功能正常  
✅ 角色权限控制生效  
✅ 用户信息可以正常更新  
✅ 登出功能清除会话  
✅ 向后兼容性保持  

**恭喜！您的JWT认证系统已经完全准备就绪！** 🔐✨
